{"version":3,"sources":["logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","App","props","handleFileRead","e","content","state","fileReader","result","response","readFile","element","document","createElement","file","Blob","excelOutput","type","href","URL","createObjectURL","download","body","appendChild","click","setState","JSONoutput","handleCreateReverse","output","reverseRead","textAreaValue","handleFileChosen","FileReader","onloadend","readAsText","getNumSpaces","str","numStart","i","length","substring","removeLeading","handleChange","event","target","value","data","finalMatrix","displayMatrix","jsonString","jsonList","JSON","parse","jsonIndex","referenced","clean","cleancheck","currFile","keys","Object","j","nextObj","includes","push","Array","isArray","toReplace","k","toCheck","match","cId","currKeys","cIds","myList","this","finalHeader","finalConcepts","maxes","conceptSeen","final","recurseRead","max","first","found","splice","toExcel","map","indexOf","join","finalArr","currItem","toInsert","currKey","hasOwnProperty","currArr","curr","key","depth","console","log","firstWithoutconceptId","toChange","arr","returned","kList","a","Math","floor","random","conceptIdList","num","generateNine","cluster","header","nameToConcept","indexVariableName","conceptIdObject","sourceJSONS","nonEmpty","conceptIdObjectKeys","conceptIdIndices","conceptIdReverseLookup","parseInt","trim","firstRowJSON","firstRow","generateRandomUUID","conceptColNames","currId","currVarName","currJSON","newJSON","collections","collectionIds","leaves","leafIndex","leafObj","currCollection","leaf","currRow","nonEmptyIndex","currValue","val","split","cid","objKeys","strData","toPush","idsToInsert","leftMost","varLabelIndex","currCluster","idsFound","leftMostStart","firstNotSource","lines","x","line","CSVToArray","lookForConcepts","nonIntersects","sort","b","toWrite","finalConceptIndices","general","getConceptIds","processCluster","toPrint","stringify","className","style","id","accept","onChange","files","rows","cols","onClick","React","Component","Boolean","window","location","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5eedf674.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\n\nclass App extends React.Component{\n  constructor(props){\n    super(props);\n    this.state ={\n      JSONoutput: [],\n      fileReader:'',\n      data: '',\n      excelOutput:'',\n      textAreaValue:'',\n      finalMatrix:[[]],\n      displayMatrix:[],\n    }\n    \n  }\n\nreverseRead(jsonString){\n    \n    let jsonList = JSON.parse(jsonString)\n    let jsonIndex = {}\n    for(let i = 0; i < jsonList.length; i++){\n        let currJSON = jsonList[i]\n        jsonIndex[currJSON['conceptId']] = i\n    }\n    \n    let referenced = [];\n    let clean = [];\n    let cleancheck = [];\n    for(let i = 0; i < jsonList.length; i++){\n        let currFile = jsonList[i];\n        let keys = Object.keys(currFile);\n        for(let j = 0; j < keys.length; j++){\n            let nextObj = currFile[keys[j]]\n            if(keys[j].includes('Source')){\n                if(!clean.includes(i)){\n                    clean.push(i)\n                    cleancheck.push(i)\n                }\n            }\n            if(Array.isArray(nextObj)){\n                //iterate through array and look for json\n                let toReplace = []\n                for(let k = 0; k < nextObj.length; k++){\n                    let toCheck = nextObj[k]\n                    \n                    if(toCheck.match(/[0-9]{9}.json/) != null){\n                        let cId = toCheck.substring(0,9);\n                        toReplace.push(jsonList[jsonIndex[cId]])\n                        if(!referenced.includes(jsonIndex[cId])){\n                            referenced.push(jsonIndex[cId])\n                        }\n                    }\n                    \n                }\n                if(toReplace.length > 0){\n                    currFile[keys[j]] = toReplace;\n                }\n            }\n            else if(typeof nextObj == 'string'){\n                if(nextObj.match(/[0-9]{9}.json/) != null){\n                    let cId = nextObj.substring(0,9);\n                    currFile[keys[j]] = jsonList[jsonIndex[cId]];\n                    if(!referenced.includes(jsonIndex[cId])){\n                        referenced.push(jsonIndex[cId])\n                    }\n                }\n                //check if string is JSON\n            }\n            else{\n                let currKeys = Object.keys(nextObj)\n                let toReplace = {};\n                for(let k = 0; k < currKeys.length; k++){\n                    if(currKeys[k].match(/[0-9]{9}.json/)){\n                        let cId = currKeys[k].substring(0,9);\n                        toReplace[nextObj[currKeys[k]]] = jsonList[jsonIndex[cId]];\n                        if(!referenced.includes(jsonIndex[cId])){\n                            referenced.push(jsonIndex[cId])\n                        }\n                    }\n                }\n                if(Object.keys(nextObj).length > 0){\n                    currFile[keys[j]] = toReplace;\n                }\n                //check object for JSON\n            }\n        }\n    }\n\n    let cIds = [];\n    for(let i = 0; i < referenced.length; i++){\n        if(!cIds.includes(jsonList[referenced[i]]['conceptId'])){\n            cIds.push(jsonList[referenced[i]]['conceptId'])\n        }\n    }\n    \n    for(let i = 0; i < jsonList.length; i++){\n        if(!cIds.includes(jsonList[i]['conceptId'])){\n            if(!clean.includes(i)){\n                clean.push(i);\n            }\n        }\n       \n    }\n    \n\n    let myList = []\n    for(let i = 0; i < clean.length; i++){\n        //if(!clean.includes(jsonList[i]['conceptId'])){\n        //if(!cleancheck.includes(clean[i]))\n            myList.push(jsonList[clean[i]]['conceptId']);\n        //}\n        //myList.push(jsonList[clean[i]]['conceptId']);\n    }\n   this.setState({finalMatrix:myList});\n\n    let finalMatrix = []\n    let finalHeader = []\n    let finalConcepts = []\n    let maxes = []\n    //change to make it recursive\n    for(let i = 0; i < clean.length; i ++){\n        let conceptSeen = [jsonList[clean[i]]['conceptId']]\n        let final = {}\n        this.recurseRead(jsonList[clean[i]],final, '', conceptSeen, 0)\n        finalMatrix.push(final)\n\n        //finalHeader.concat(Object.keys(final)).unique()\n\n\n\n        let keys = Object.keys(final)\n        let finalArr = []\n        let max = 0;\n        for(let j = 0; j < keys.length; j++){\n            if(!finalHeader.includes(keys[j]) && !finalConcepts.includes(keys[j])){\n                if(!keys[j].includes('conceptId')){\n                    if(!keys[j].includes('subcollection') && !keys[j].includes('subcollections')){\n                        finalHeader.push(keys[j])\n                    }\n                }\n                else{\n                    finalConcepts.push(keys[j])\n                }\n            }\n\n            if(final[keys[j]].length > max){\n                max = final[keys[j]].length\n            }\n        }\n\n        maxes.push(max)\n        \n        //console.log(finalArr)\n\n\n    }\n    /*\n    let toExcel = \"\";\n    toExcel += keys.map(function(value){\n        if(value.indexOf(',') != -1){\n            return \"\\\"\" + value + \"\\\"\";\n        }\n        else if(value == '0'){\n            return ''\n        }\n        else{\n            return value;\n        }\n    }).join(\",\");\n    for(let j = 0; j < finalArr.length; j++){\n        toExcel += '\\n'\n        toExcel += finalArr[j].map(function(value){\n            if(value.indexOf(',') != -1){\n                return \"\\\"\" + value + \"\\\"\";\n            }\n            else{\n                return value;\n            }\n        }).join(\",\");\n    }\n    //console.log(toExcel)\n    fs.writeFileSync('testOutput1.csv', toExcel)\n*/\n    //\n    //reorder the finalHeader\n    //console.log(finalConcepts)\n    //try while organizing data: if key == subcollection, use single key from thing\n    let first = false;\n    for(let i = 0; i < finalHeader.length; i++){\n        let found = false;\n        for(let j = 0; j < finalConcepts.length; j++){    \n            if(finalConcepts[j].includes(finalHeader[i])){\n                finalHeader.splice(i,0,finalConcepts[j])\n                i += 1;\n                j = finalConcepts.length\n                found =true\n            }\n        }\n        if(found == false && first == false){\n            finalHeader.splice(i,0,'conceptId')\n            i += 1;\n            first = true;\n        }\n        \n    }\n    //console.log(finalHeader)\n\n\n\n    let toExcel = ''\n    toExcel += finalHeader.map(function(value){\n        if(value.indexOf(',') != -1){\n            return \"\\\"\" + value + \"\\\"\";\n        }\n        else if(value == '0'){\n            return ''\n        }\n        else{\n            return value;\n        }\n    }).join(\",\");\n    //console.log(finalMatrix[1])\n    for(let i =0 ; i < finalMatrix.length; i++){\n       \n        let max = maxes[i]\n        let finalArr = [];\n        let currItem = finalMatrix[i] \n    \n        for(let k = 0; k < max; k++){\n            let toInsert = []\n            for(let j = 0; j < finalHeader.length; j++){\n\n                toInsert.push('')\n\n            }\n            finalArr.push(toInsert);\n        }\n        for(let j = 0; j < finalHeader.length; j++){\n            let currKey = finalHeader[j]\n            \n            if(currItem.hasOwnProperty(currKey)){\n                let currArr = currItem[currKey]\n                if(currKey != '0'){\n                    for(let k = 0; k < currArr.length; k++){\n                        finalArr[k][j] = currArr[k]\n                    }\n                }\n            }\n        }\n        for(let j = 0; j < finalArr.length; j++){\n            toExcel += '\\n'\n            toExcel += finalArr[j].map(function(value){\n                if(value.indexOf(',') != -1){\n                    return \"\\\"\" + value + \"\\\"\";\n                }\n                else{\n                    return value;\n                }\n            }).join(\",\");\n        }\n\n    }    \n        \n    \n\n\n    return toExcel;\n    //console.log(toExcel)\n    //console.log(finalConcepts)\n}\n\nrecurseRead(curr,final, key, conceptSeen, depth){\n    console.log(depth)\n    let keys = Object.keys(curr)\n    let toPrint = []\n\n    if(curr.hasOwnProperty('conceptId') && key != ''){\n        let nextObj = curr['conceptId']\n        if(key == 'subcollections' || key == 'subcollection'){\n            let found = -1;\n            let firstWithoutconceptId = -1;\n            for(let i = 0; i < keys.length; i++){\n                if(final.hasOwnProperty('conceptId' + keys[i]) && keys[i] != '' && keys[i] != 'subcollections'&& keys[i] != 'subcollection' && found == -1){\n                    found = i;\n                }\n                if(!keys[i].includes('conceptId') && firstWithoutconceptId == -1 && keys[i] != 'subcollections'&& keys[i] != 'subcollection'){\n                    firstWithoutconceptId = i\n                }\n            }\n            let toChange = ''\n            if(found == -1){\n                toChange = keys[firstWithoutconceptId]\n            }\n            else{\n                toChange = keys[found]\n            }\n            \n            if(final.hasOwnProperty('conceptId' + toChange)){\n                if(!final['conceptId' + toChange].includes(nextObj)){\n                    final['conceptId' + toChange].push(nextObj)\n                }\n            }\n            else{\n                final['conceptId' + toChange] = [nextObj]\n            }\n        }\n        else{\n            if(final.hasOwnProperty('conceptId' + key)){\n                if(!final['conceptId' + key].includes(nextObj)){\n                    final['conceptId' + key].push(nextObj)\n                }\n            }\n            else{\n                final['conceptId' + key] = [nextObj]\n\n            }\n        }\n    }\n    \n    for(let j = 0; j < keys.length; j++){\n        let nextObj = curr[keys[j]]\n        if(Array.isArray(nextObj)){\n            let arr = []\n            for(let k = 0; k <nextObj.length; k++){\n                if(typeof nextObj[k] != 'string'){\n                    if(!conceptSeen.includes(nextObj[k]['conceptId'])){\n                        conceptSeen.push(nextObj['conceptId'])\n                        if(!key.includes('Source')){\n                            let returned = this.recurseRead(nextObj[k], final, keys[j], conceptSeen, depth + 1)\n                            arr.push(returned)\n                        }\n                    }\n                }\n                else{\n                    //console.log(JSON.stringify(nextObj))\n                }\n                \n            }\n            //console.log(keys[j])\n            //console.log(arr)\n        }\n\n        else if(typeof nextObj == 'string'){\n            if(keys[j] != 'conceptId' && key != 'conceptId'){\n                if(key == '' || key == 'subcollection'){\n                    if(final.hasOwnProperty(keys[j])){\n                        if(!final[keys[j]].includes(nextObj)){\n                            final[keys[j]].push(nextObj)\n                        }\n                    }\n                    else{\n                        final[keys[j]] = [nextObj]\n                    }\n                    //toPrint.push(keys[j] + ':' + nextObj)\n                    //console.log(keys[j] + ': ' + nextObj)\n                }\n                else{\n                    if(final.hasOwnProperty(key)){\n                        if(!final[key].includes(nextObj)){\n                            final[key].push(nextObj)\n                        }\n                        \n                    }\n                    else{\n                        final[key] = [nextObj]\n                    }\n                    //toPrint.push(key + ':' + nextObj)\n                    //console.log(key + ': ' + nextObj)\n                }\n            }\n\n            else if(keys[j] == 'conceptId' && key == ''){\n                if(final.hasOwnProperty('conceptId' + key)){\n                    if(!final['conceptId' + key].includes(nextObj)){\n                        final['conceptId' + key].push(nextObj)\n                    }\n                }\n                else{\n                    final['conceptId' + key] = [nextObj]\n                }\n            }\n        \n        }\n\n\n        else{\n            if(!nextObj.hasOwnProperty('conceptId') || !conceptSeen.includes(nextObj['conceptId'])){\n                if(nextObj.hasOwnProperty('conceptId')){\n                    conceptSeen.push(nextObj['conceptId'])\n                    this.recurseRead(nextObj, final, keys[j], conceptSeen, depth + 1)\n                }\n                else{\n                    let kList = Object.keys(nextObj);\n                    \n                    for(let k = 0; k < kList.length; k++){\n\n                        if(nextObj[kList[k]].hasOwnProperty('Variable Name') && !nextObj[kList[k]]['Variable Name'].includes('=')){\n                            nextObj[kList[k]]['Variable Name'] = kList[k] + '=' + nextObj[kList[k]]['Variable Name']\n                        }\n                        if(nextObj[kList[k]].hasOwnProperty('conceptId') && !conceptSeen.includes(nextObj[kList[k]]['conceptId'])){\n                            conceptSeen.push(nextObj[kList[k]]['conceptId'])\n                            this.recurseRead(nextObj[kList[k]], final, keys[j], conceptSeen, depth + 1)\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n    //console.log(toPrint)\n\n}\n\n  \ngenerateNine(){\n  let a = ''\n  for(let i = 0; i < 9; i++){\n      let b = Math.floor(Math.random()*10)\n      a += b\n  }\n  return a;\n}\n\ngenerateRandomUUID(conceptIdList){\n  //return uuidv4();\n  let num = this.generateNine()\n  while(!conceptIdList.includes(num)){\n      let num = this.generateNine();\n      return num;\n  }\n}\n\nprocessCluster(cluster, header, nameToConcept, indexVariableName, conceptIdList, conceptIdObject, sourceJSONS, jsonList){\n    let nonEmpty = [];\n    let list = [1,2,3]\n    let conceptIdObjectKeys =Object.keys(conceptIdObject)\n    let conceptIdIndices = [];\n    let generalId = -1;\n    let conceptIdReverseLookup = {};\n    for(let i = 0; i < conceptIdObjectKeys.length; i++){\n        conceptIdIndices.push(parseInt(conceptIdObjectKeys[i]))\n        conceptIdReverseLookup[conceptIdObject[conceptIdObjectKeys[i]]] = parseInt(conceptIdObjectKeys[i])\n    }\n\n    for(let i = 1; i < cluster.length; i++){\n        let currArr = cluster[i]\n        for(let j = 0; j < currArr.length; j++){\n            if(currArr[j].trim()!='' && !conceptIdIndices.includes(j)){\n                if(!nonEmpty.includes(j)){\n                    nonEmpty.push(j)\n                }\n            }\n        }\n    }\n    /*console.log(cluster.length)\n    console.log(JSON.stringify(conceptIdIndices))\n    console.log(JSON.stringify(header))\n    console.log(JSON.stringify(nonEmpty))\n    */\n    let firstRowJSON = {}\n    let firstRow = cluster[0]\n    let clump = [];\n    let findIndex = 0;\n    //console.log(JSON.stringify(conceptIdObject))\n    for(let i = 0; i < firstRow.length; i++){\n        if(conceptIdIndices.includes(i) && conceptIdObject[i] ==\"thisRowId\"){\n            findIndex = i;\n        }\n        if(firstRow[i] != \"\" && !nonEmpty.includes(i) || (conceptIdIndices.includes(i) && conceptIdObject[i] ==\"thisRowId\")){\n            \n            firstRowJSON[header[i]] = firstRow[i]\n        }\n    }\n    //console.log(JSON.stringify(cluster[0]))\n    //console.log()\n    //console.log(JSON.stringify(firstRowJSON))\n    if(!firstRowJSON.hasOwnProperty('conceptId') || firstRowJSON['conceptId'] == ''){\n        if(nameToConcept.hasOwnProperty(firstRow[indexVariableName])){\n            firstRowJSON['conceptId'] = nameToConcept[firstRow[indexVariableName]]\n            //console.log(nameToConcept[firstRow[indexVariableName]])\n            if(!conceptIdList.includes(firstRowJSON['conceptId'])){\n                conceptIdList.push(firstRowJSON['conceptId'])\n            }\n        }\n        else{\n             firstRowJSON['conceptId'] = this.generateRandomUUID(conceptIdList);\n             conceptIdList.push(firstRowJSON['conceptId'])\n             nameToConcept[firstRow[indexVariableName]] = firstRowJSON['conceptId']\n        }\n    }\n    firstRow[conceptIdReverseLookup['thisRowId']] = firstRowJSON['conceptId']\n    //console.log(JSON.stringify(firstRowJSON))\n    //console.log(JSON.stringify(firstRow))\n    //find sources first\n    let conceptColNames = Object.keys(conceptIdReverseLookup)\n    for(let i = 0; i < conceptColNames.length; i++){\n        if(conceptColNames[i].indexOf('Source') != -1){\n            let currId = firstRow[conceptIdReverseLookup[conceptColNames[i]]]\n            \n            let currVarName = firstRow[conceptIdReverseLookup[conceptColNames[i]] + 1]\n            //console.log(currVarName )\n            \n            if(currId == '' && nameToConcept.hasOwnProperty(currVarName)){\n                currId = nameToConcept[currVarName]\n            }\n\n            let found = -1;\n            for(let j = 0; j < sourceJSONS.length; j++){\n                let currJSON = sourceJSONS[j];\n                if(currId != '' && currJSON['conceptId'] == currId){\n                    found = i;\n                    if(!currJSON['subcollections'].includes(firstRowJSON['conceptId'] + '.json')){\n                        currJSON['subcollections'].push(firstRowJSON['conceptId'] + '.json')\n                    }\n                    j = sourceJSONS.length;\n                }\n                else if(currId == '' && currVarName == currJSON['Variable Name']){\n                    found = i;\n                    currId = currJSON['conceptId'];\n                    if(!currJSON['subcollections'].includes(firstRowJSON['conceptId'] + '.json')){\n                        currJSON['subcollections'].push(firstRowJSON['conceptId'] + '.json')\n                    }\n                    j = sourceJSONS.length\n                }\n            }\n            if(found == -1){\n                let newJSON = {}\n                if(currId == '' && currVarName != ''){\n                    currId = this.generateRandomUUID(conceptIdList);\n                }\n                \n                newJSON['conceptId'] = currId;\n                newJSON['Variable Name'] = currVarName;\n                newJSON['subcollections'] = [firstRowJSON['conceptId'] + '.json']\n                sourceJSONS.push(newJSON)\n            }\n            nameToConcept[currVarName] = currId\n            if(!conceptIdList.includes(currId)){\n                conceptIdList.push(currId)\n            }\n            \n            firstRowJSON[header[conceptIdReverseLookup[conceptColNames[i]] + 1]] = currId + '.json'\n            firstRow[conceptIdReverseLookup[conceptColNames[i]]] = currId;\n            \n        }\n    }\n\n    let collections = [];\n    let collectionIds = [];\n    let leaves = []\n    let leafIndex = -1;\n    let leafObj = {}\n    for(let i = 0; i < cluster.length; i++){\n        let ids = [];\n        let currCollection = {}\n        let leaf = ''\n        let currRow = cluster[i];\n        for(let j = 0; j < nonEmpty.length; j++){\n            let currObject = {} \n            \n            let nonEmptyIndex = nonEmpty[j];\n\n            \n            let currValue = currRow[nonEmptyIndex]\n            \n           \n            if(currValue.indexOf('=') != -1){\n                leaf = currValue;\n                leafIndex = nonEmptyIndex;\n                leaves.push(currValue)\n                let val = leaf.split('=')[1].trim()\n                let key = leaf.split('=')[0].trim()\n                let cid = this.generateRandomUUID(conceptIdList)\n                if(nameToConcept.hasOwnProperty(val)){\n                    cid = nameToConcept[val]\n                }\n                if(currRow[leafIndex - 1] != ''){\n                    cid = currRow[leafIndex-1];\n                }\n                \n                //fs.writeFileSync(cid + '.json', JSON.stringify({'conceptId':cid, 'variableName':val}));\n                jsonList.push({'conceptId':cid, 'Variable Name':val})\n                nameToConcept[val] = cid\n                \n                if(!conceptIdList.includes(cid)){\n                    conceptIdList.push(cid)\n                }\n                leafObj[cid + '.json'] = key\n                currRow[leafIndex-1] = cid\n            }\n            \n            else{\n                if(currRow[nonEmptyIndex] != ''){\n                    currCollection[header[nonEmptyIndex]] = currRow[nonEmptyIndex]\n                }\n            }\n            \n        }\n        if(conceptIdReverseLookup.hasOwnProperty('leftMostId') && currRow[conceptIdReverseLookup['leftMostId']] != ''){\n            currCollection['conceptId'] = currRow[conceptIdReverseLookup['leftMostId']]\n        }\n        if(Object.keys(currCollection).length != 0){\n            let cid = this.generateRandomUUID(conceptIdList)\n            let objKeys = Object.keys(currCollection);\n            for(let i = 0; i < objKeys.length; i++){\n                let key = objKeys[i];\n                if(nameToConcept.hasOwnProperty(currCollection[key])){\n                    cid = nameToConcept[currCollection[key]]\n                }\n            }\n            \n            if(currCollection.hasOwnProperty('conceptId')){\n                cid = currCollection['conceptId'];\n            }\n            if(!conceptIdList.includes(cid)){\n                conceptIdList.push(cid);\n            }\n            currCollection['conceptId'] = cid;\n            collectionIds.push(cid + '.json')\n            for(let i = 0; i < objKeys.length; i++){\n                let key = objKeys[i]\n                nameToConcept[currCollection[key]] = cid;\n            }\n            collections.push(currCollection);\n            cluster[i][conceptIdReverseLookup['leftMostId']] = cid;\n            //fs.writeFileSync(cid + '.json', currCollection);\n        }   \n    }\n\n    if(collections.length == 0  && leaves.length > 0){\n        firstRowJSON[header[leafIndex]] = leafObj;\n    }\n    else{\n        if(collectionIds.length != 0){\n            firstRowJSON['subcollection'] = collectionIds;\n        }\n        for(let i = 0; i < collections.length; i++){\n            let currCollection = collections[i]\n            currCollection[header[leafIndex]] = leafObj;\n            //fs.writeFileSync(currCollection['conceptId']+ '.json', JSON.stringify(currCollection));\n            jsonList.push(currCollection)\n\n        }\n    }\n    \n    if(cluster[0][conceptIdReverseLookup['thisRowId']] == ''){\n        firstRowJSON['conceptId'] = this.generateRandomUUID(conceptIdList);\n        if(nameToConcept.hasOwnProperty(firstRowJSON[header[indexVariableName]])){\n            firstRowJSON['conceptId'] = nameToConcept[firstRowJSON[header[indexVariableName]]];\n        }\n        cluster[0][conceptIdReverseLookup['thisRowId']] = firstRowJSON['conceptId']\n        nameToConcept[firstRowJSON[header[indexVariableName]]] = firstRowJSON['conceptId']\n    }\n    else{\n        firstRowJSON['conceptId'] = cluster[0][conceptIdReverseLookup['thisRowId']]\n        nameToConcept[firstRowJSON[header[indexVariableName]]] = firstRowJSON['conceptId']\n    }\n    jsonList.push(firstRowJSON);\n    return cluster;\n\n\n}\n\nCSVToArray(strData){\n  strData = strData.trim()\n  let arr = [];\n  while(strData.indexOf(\",\") != -1 ){\n      let toPush = \"\";\n      if(strData.substring(0,1) == \"\\\"\"){\n          strData = strData.substring(1);\n          toPush = strData.substring(0,  strData.indexOf(\"\\\"\"));    \n          strData = strData.substring(strData.indexOf(\"\\\"\") + 1);    \n          strData = strData.substring(strData.indexOf(',')+1)\n      }\n      else{\n          toPush = strData.substring(0, strData.indexOf(','));\n          strData = strData.substring(strData.indexOf(',') + 1)\n      }\n      arr.push(toPush)\n\n      //let nextQuote = strData.indexOf(\"\\\"\")\n  }\n    arr.push(strData);\n\n  // Return the parsed data.\n  return( arr );\n}\n\nlookForConcepts(cluster, header, idsToInsert, leftMost){\n  let leafIndex = -1;\n  let nonEmpty = [];\n  for(let i = 1; i < cluster.length; i++){\n      let currArr = cluster[i]\n      for(let j = 0; j < currArr.length; j++){\n          if(currArr[j]!=''){\n              if(!nonEmpty.includes(j)){\n                  nonEmpty.push(j)\n              }\n              if(currArr[j].indexOf('=') != -1){\n                  if(!idsToInsert.includes(j)){\n                      idsToInsert.push(j)    \n                  }\n                  leafIndex = j\n              }\n          }\n      }\n  }\n  for(let i = 0; i < nonEmpty.length; i++){\n      if(nonEmpty[i] != leafIndex && nonEmpty[i] < leftMost[0] && header[nonEmpty[i]] != 'conceptId'){\n          leftMost[0] = nonEmpty[i];\n          leftMost[1] = header[nonEmpty[i]]\n      }\n  }\n  //identify which one is the leaf\n\n}\n\ngetConceptIds(data){\n\n  //first, get all columns that require conceptids\n  //next, check if column to the right has concept id\n  //if it does, add to array, if it doesnt, maybe add to file\n  //keywords: source\n  //Look for columns with clusters\n  let varLabelIndex = 0;\n  let cluster = []\n  let first = true;\n  let currCluster = false;\n  let header = [];\n  let idsToInsert = [];\n  let idsFound = []\n  let conceptIdIndices = []\n  let leftMost = []\n  let leftMostStart = -1;\n  let firstNotSource = -1;\n  let lines = data.split('\\n')\n\n  for(let x = 0; x < lines.length; x++){\n      let line = lines[x]\n\n      //let arr = line.split(',');\n      let arr = this.CSVToArray(line, ',')\n      if(first){\n          header = arr;\n          first = false;\n          for(let i = 0; i < arr.length; i++){\n              if(arr[i] == \"Variable Name\"){\n                  varLabelIndex = i;\n              }\n              if(arr[i].indexOf('Source') != -1){\n                  idsToInsert.push(i)\n              }\n              else if(arr[i].indexOf('conceptId') != -1){\n                  conceptIdIndices.push(i)\n                  idsFound.push(arr[i])\n              }\n              else{\n                  if(firstNotSource == -1 && arr[i] != ''){\n                      idsToInsert.push(i)\n                      firstNotSource = i\n                  }\n              }\n              \n          }\n          leftMostStart = arr.length;\n          leftMost.push(arr.length)\n          leftMost.push('')\n      }\n      else if(currCluster){\n          if(arr[varLabelIndex] == ''){\n              cluster.push(arr);\n          }\n          else{\n              this.lookForConcepts(cluster, header, idsToInsert, leftMost)\n          }\n      }\n      else{\n          cluster.push(arr)\n          currCluster = true;\n      }\n  }\n  this.lookForConcepts(cluster, header, idsToInsert, leftMost);\n  \n  if(!idsToInsert.includes(leftMost[0]) && leftMost[0] != leftMostStart){\n      idsToInsert.push(leftMost[0])\n  }\n  //console.log(JSON.stringify(idsToInsert))\n\n  //console.log(JSON.stringify(conceptIdIndices))\n  let nonIntersects = []\n  for(let i = 0; i < idsToInsert.length; i++){\n      let found = false;\n      for(let j = 0; j < conceptIdIndices.length; j++){\n          if(idsToInsert[i] == conceptIdIndices[j] + 1){\n              found = true;\n          }\n      }\n      if(found == false){\n          nonIntersects.push(idsToInsert[i])\n      }\n  }\n\n  //sorts in descending order\n  nonIntersects.sort(function(a, b){return b - a})\n  let toWrite ='';\n  first = true;\n  let finalConceptIndices = {};\n  lines = data.split('\\n')\n  //console.log(nonIntersects)\n  for (let x = 0; x < lines.length; x ++){\n      \n      let line = lines[x]\n      //let arr = line.split(',')\n      let arr = this.CSVToArray(line)\n      //console.log(JSON.stringify(arr))\n      if(first == true){\n          let general = arr[firstNotSource]\n          for(let i = 0; i < nonIntersects.length; i++){\n              arr.splice(nonIntersects[i],0,'conceptId')\n          }\n          toWrite += arr.map(function(value){\n            if(value.indexOf(',') != -1){\n                return \"\\\"\" + value + \"\\\"\";\n            }\n            else{\n                return value;\n            }\n          }).join(\",\");\n          first = false;\n          for(let i = 0; i < arr.length; i++){\n              if(arr[i].includes('conceptId') && i != arr.length - 1){\n                  if(arr[i+1] == general){\n                      finalConceptIndices[i] = 'thisRowId'\n                  }\n                  else if(arr[i+1] == leftMost[1]){\n                      finalConceptIndices[i] = 'leftMostId'\n                  }\n                  else{\n                      finalConceptIndices[i] = arr[i+1]\n                  }\n              }\n          }\n      }   \n      else{\n          //console.log(arr)\n          for(let i = 0; i < nonIntersects.length; i++){\n              arr.splice(nonIntersects[i],0,'')\n          }\n          toWrite += '\\n'\n          toWrite += arr.map(function(value){\n            if(value.indexOf(',') != -1){\n                return \"\\\"\" + value + \"\\\"\";\n            }\n            else{\n                return value;\n            }\n        }).join(\",\");\n      }\n  }\n\n  this.state.data = toWrite;\n  return finalConceptIndices;\n}\n\nreadFile(data){\n  let jsonList = []\n  let sourceJSONS = []\n  let ConceptIndex = '{}'\n  let idIndex = '[]'\n  let conceptIdList = JSON.parse(idIndex)\n  let varLabelIndex = 0;\n  let cluster = []\n  let conceptIdObject = this.getConceptIds(data)\n  \n  let excelOutput = []\n\n  let first = true;\n  let currCluster = false;\n  let header = [];\n  let nameToConcept = JSON.parse(ConceptIndex);\n  let lines = this.state.data.split('\\n')\n  //console.log(this.state.data)\n\n  for (let x = 0; x < lines.length; x++){\n      //let arr = line.split(',');\n      let line = lines[x]\n      let arr = this.CSVToArray(line, ',')\n      //console.log(JSON.stringify(arr))\n      //console.log(line)\n      if(first){\n          header = arr;\n          first = false;\n          for(let i = 0; i < arr.length; i++){\n              if(arr[i] == \"Variable Name\"){\n                  varLabelIndex = i;\n              }\n          }\n          excelOutput.push([arr])\n      }\n      else if(currCluster){\n          if(arr[varLabelIndex] == ''){\n              cluster.push(arr);\n          }\n          else{\n              let returned = this.processCluster(cluster, header, nameToConcept, varLabelIndex, conceptIdList, conceptIdObject, sourceJSONS, jsonList)\n              excelOutput.push(returned)\n              cluster = [arr]\n              currCluster = true;\n          }\n      }\n      else{\n          cluster.push(arr)\n          currCluster = true;\n      }\n  }\n  let returned = this.processCluster(cluster, header, nameToConcept, varLabelIndex, conceptIdList, conceptIdObject, sourceJSONS, jsonList);\n  excelOutput.push(returned)\n  for(let i = 0; i < sourceJSONS.length; i++){\n      jsonList.push(sourceJSONS[i])\n  }\n  \n  let toPrint = '';\n  for(let i=0; i < excelOutput.length; i++){\n      let cluster = excelOutput[i]\n      for(let j = 0; j < cluster.length; j++){\n          let row = cluster[j]\n          toPrint += cluster[j].map(function(value){\n              if(value.indexOf(',') != -1){\n                  return \"\\\"\" + value + \"\\\"\";\n              }\n              else{\n                  return value;\n              }\n          }).join(\",\");\n          if(i!=excelOutput.length-1 || j!=cluster.length -1){\n              toPrint += '\\n'\n          }\n      }\n  }\n  this.setState({excelOutput:toPrint})\n  let toReturn = ''\n  for(let i = 0; i < jsonList.length; i++){\n    toReturn += JSON.stringify(jsonList[i], null, '    ') + '\\n'\n  }\n  //return JSON.stringify(jsonList, null, '\\t');\n  return jsonList\n\n}\n\n\n  handleFileRead = (e) => {\n    const content = this.state.fileReader.result;\n    let response = this.readFile(content)\n    const element = document.createElement(\"a\");\n    const file = new Blob([this.state.excelOutput], {type: 'text/plain'});\n    element.href = URL.createObjectURL(file);\n    element.download = \"myFile.csv\";\n    document.body.appendChild(element); // Required for this to work in FireFox\n    element.click();\n    //console.log(JSON.stringify(response))\n    this.setState({JSONoutput:response})\n  }\n  \n  handleCreateReverse = (e) => {\n    let output = this.reverseRead(this.state.textAreaValue)\n    //console.log(output)\n    const element = document.createElement(\"a\");\n    const file = new Blob([output], {type: 'text/plain'});\n    element.href = URL.createObjectURL(file);\n    element.download = \"myFile.csv\";\n    document.body.appendChild(element); // Required for this to work in FireFox\n    element.click();\n  }\n\n  handleFileChosen = (file) => {\n    this.state.fileReader = new FileReader();\n    this.state.fileReader.onloadend = this.handleFileRead;\n    this.state.fileReader.readAsText(file);\n  }\n  getNumSpaces=(str) =>{\n    let numStart = 0;\n    for(let i = 0; i < str.length; i++){\n      if(str.substring(i, i+1) == '-'){\n        numStart += 1;\n      }\n      else{\n        return numStart * 16 + 'px'\n      }\n    }\n    return numStart * 16 + 'px';\n  }\n  removeLeading = (str)=>{\n    let numStart = 0;\n    for(let i = 0; i < str.length; i++){\n      if(str.substring(i, i+1) == '-'){\n        numStart += 1;\n      }\n      else{\n        return str.substring(numStart)\n      }\n    }\n    return str.substring(numStart);\n  }\n  handleChange = (event) =>{\n    //console.log(this.state.textAreaValue)\n    this.setState({textAreaValue:event.target.value})\n  }\n  render(){\n    return (\n      <div className=\"App\" style={{'text-align':'left'}}>\n        <header className=\"App-header\" style = {{'font-size':'16px', 'padding-top':'50px', 'padding-bottom':'50px'}}>\n          <h2>CSV to JSONS</h2>\n          <input type='file'\n                 id='file'\n                 className='input-file'\n                 accept='.csv'\n                 onChange={e=>this.handleFileChosen(e.target.files[0])}\n          ></input>\n          <div style = {{'text-align':'center'}}>\n              <p>CSV Rules:</p>\n              <p>There must be a Variable Name field in every full row</p>\n              <p>The leaf nodes (final unit of response) is the only row that is allowed to have an equals sign</p>\n          </div>\n          \n          <div style = {{'padding-left': '50px', 'padding-right':'50px'}}>\n              {/*this.state.JSONoutput.map(s => (<p>{JSON.stringify(s, null, '-').split('\\n').map((item) => {\n                return (\n                  <span style = {{'padding-left':this.getNumSpaces(item)}}>\n                  {this.removeLeading(item)}\n                  <br/>\n                  </span>\n                )\n              })}</p>))*/\n              JSON.stringify(this.state.JSONoutput)}\n          </div>\n          <br/>\n          <br/>\n          <h2>JSONS to CSV</h2>\n          <p>Enter a list of JSONS, and we will generate a csv file for it</p>\n          <div>\n            <textarea\n                value={this.state.textAreaValue}\n                onChange={this.handleChange}\n                rows={10}\n                cols={50}\n                />\n          </div>\n          <button type=\"button\" onClick={this.handleCreateReverse}>Convert!</button>\n          <div style = {{'word-wrap': 'break-word','padding-left': '50px', 'padding-right':'50px'}}><p>{JSON.stringify(this.state.finalMatrix)/*(this.state.finalMatrix.map(s => JSON.stringify(s))).toString()*/}</p></div>\n        </header>\n\n      </div>\n    );\n  }\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}